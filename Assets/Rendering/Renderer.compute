// ReSharper disable CppTooWideScope
#pragma kernel csMain

float time;
float2 camRotation;
float2 resolution;
float3 cameraPos;
RWTexture2D<float4> screenTexture;

struct sdfInfo
{
    float dist;
    float3 color;
};

struct objectInfo
{
    sdfInfo info;
    float blend;
};

struct sdfResult
{
    float dist;
    float3 color;
};

float2x2 rot2D(float angle)
{
    float s = sin(angle);
    float c = cos(angle);
    return float2x2(c, -s, s, c);
}

float2 opSmoothUnion(float a, float b, float k)
{
    float h = 1.0 - min(abs(a - b) / (4.0 * k), 1.0);
    float w = h * h;
    float m = w * 0.5;
    float s = w * k;
    return a < b ? float2(a - s, m) : float2(b - s, 1.0 - m);
}

sdfInfo sdfGround(float3 pos, float groundLevel, float3 color)
{
    sdfInfo result;
    result.dist = pos.y - groundLevel;
    result.color = color;
    return result;
}

sdfInfo sdfSphere(float3 pos, float3 objPos, float radius, float3 color)
{
    sdfInfo result;
    result.dist = length(pos - objPos) - radius;
    result.color = color;
    return result;
}

sdfInfo sdfBox(float3 pos, float3 objPos, float3 dimensions, float3 color)
{
    sdfInfo result;
    pos -= objPos;
    float3 q = abs(pos) - dimensions;
    result.dist = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
    result.color = color;
    return result;
}

sdfResult sdfScene(float3 pos)
{
    float minDist = 100.0;
    float3 color = 0.0;
    
    objectInfo distances[3] = {
        sdfSphere(pos, float3(sin(time) * 2, 0, 0), 1.0, float3(1, 0.5, 0.5)), 0.5,
        sdfBox(pos, float3(-sin(time) * 2, 0, 0), 1.0, float3(0.5, 0.5, 1)), 0.5,
        sdfGround(pos, cos(time) * 0.5 - 2.0, float3(0.5, 1, 0.5)), 0.25
    };

    for (int i = 0; i < 3; i++)
    {
        float2 result = opSmoothUnion(minDist, distances[i].info.dist, distances[i].blend);
        minDist = result.x;
        color = lerp(color, distances[i].info.color, result.y);
    }

    sdfResult result;

    result.dist = minDist;
    result.color = color;

    return result; 
}

float2 normalizeScreenCoords(float2 screenCoord)
{
    float2 result = 2.0 * (screenCoord / resolution.xy - 0.5);
    result.x *= resolution.x / resolution.y; // Correct for aspect ratio
    return result;
}

float3 calculateNormal(float3 pos, float centerDistance)
{
    float epsilon = 0.01; 
    float xDistance = sdfScene(pos + float3(epsilon, 0, 0)).dist;
    float yDistance = sdfScene(pos + float3(0, epsilon, 0)).dist;
    float zDistance = sdfScene(pos + float3(0, 0, epsilon)).dist;
    float3 normal = (float3(xDistance, yDistance, zDistance) - centerDistance) / epsilon;
    return normal;
}

float calcLight(float3 normal, float3 viewDir, float metallicness)
{
    const float3 lightDir = normalize(float3(-1, -1, 1));
    float ambientLight = 0.25;
    float diffuseLight = max(0.0, dot(normal, -lightDir));
    float3 reflectSource = normalize(reflect(-lightDir, normal));
    float specularLight = max(0.0, dot(viewDir, reflectSource));
    specularLight = pow(specularLight, 16.0);
    
    return ambientLight * 1.0 + diffuseLight * 1.0 + specularLight * metallicness;
}

[numthreads(8,8,1)]
void csMain (uint3 id : SV_DispatchThreadID)
{
    const float distThreshold = 0.01;
    const float maxDist = 100.0;
    const int maxIterations = 150;
    const float outlineThreshold = 0;
    const float3 skyColor = float3(0.675, 0.845, 0.95);
    const float2 uv = normalizeScreenCoords(id.xy);
    const float3 origin = cameraPos;
    
    float3 dir = normalize(float3(uv, 1.0));

    dir.yz = mul(dir.yz, rot2D(-camRotation.x));
    dir.xz = mul(dir.xz, rot2D(camRotation.y));

    float3 objColor = 0;
    float3 surfaceNormal = 0;
    float totalDist = 0.0;

    bool didHit = false;
    bool isOutline = false;
    
    for (int i = 0; i < maxIterations; i++)
    {
        float3 pos = origin + dir * totalDist;
        sdfResult result = sdfScene(pos);
        float dist = result.dist;
        objColor = result.color;
        totalDist += dist;

        if (dist < distThreshold)
        {
            didHit = true;
            isOutline = false;
            surfaceNormal = calculateNormal(pos, dist);
            break;
        } if (dist < outlineThreshold)
            isOutline = true;

        if (totalDist > maxDist) break;
    }
    
    if (isOutline)
        screenTexture[id.xy] = 1;
    else if (didHit)
    {
        screenTexture[id.xy] = float4(objColor, 1) * calcLight(surfaceNormal, dir, 1.0);
    }
    else screenTexture[id.xy] = float4(skyColor, 1);
}
