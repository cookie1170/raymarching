// ReSharper disable CppTooWideScope
#pragma kernel csMain

struct shapeTransform
{
    float3 position;
    float3 rotation;
};

struct shapeInfo
{
    float3 dimensions;
    float blendAmount;
};

struct shape
{
    float4 colour;
    shapeTransform transform;
    shapeInfo info;
    int type;
    int operation;
};

struct sdfResult
{
    float dist;
    float3 colour;
};

float time;
float2 camRotation;
float2 resolution;
float3 cameraPos;
RWTexture2D<float4> screenTexture;
StructuredBuffer<shape> shapes;

float2x2 rot2D(const float angle)
{
    float s = sin(angle);
    float c = cos(angle);
    return float2x2(c, -s, s, c);
}

float2 opSmoothUnion(const float a, const float b, const float k)
{
    float h = 1.0 - min(abs(a - b) / (4.0 * k), 1.0);
    float w = h * h;
    float m = w * 0.5;
    float s = w * k;
    return a < b ? float2(a - s, m) : float2(b - s, 1.0 - m);
}

float opSmoothSubtraction(float d1, float d2, float k)
{
    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);
    return lerp(d2, -d1, h) + k * h * (1.0 - h);
}

float opSmoothIntersection(float d1, float d2, float k)
{
    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);
    return lerp(d2, d1, h) + k * h * (1.0 - h);
}

float sdfPlane(float3 pos, const shape shape)
{
    pos -= shape.transform.position;
    return dot(pos, normalize(shape.info.dimensions));
}

float sdfSphere(float3 pos, const shape shape)
{
    pos -= shape.transform.position;
    float result = length(pos) - shape.info.dimensions.x;
    return result;
}

float sdfBox(float3 pos, const shape shape)
{
    pos -= shape.transform.position;
    float3 q = abs(pos) - shape.info.dimensions;
    float result = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
    return result;
}

float sdfShape(float3 pos, shape shape)
{
    switch (shape.type)
    {
    default:
        return sdfSphere(pos, shape);
    case 1:
        return sdfBox(pos, shape);
    case 2:
        return sdfPlane(pos, shape);
    }
}

sdfResult sdfScene(const float3 pos)
{
    float minDist = 100.0;
    float3 colour = 0.0;

    uint count;
    // ReSharper disable once CppEntityAssignedButNoRead
    uint stride;
    // ReSharper disable once CppAssignedValueIsNeverUsed
    shapes.GetDimensions(count, stride);
    
    for (uint i = 0; i < count; i++)
    {
        shape shape = shapes[i];
        float dist = sdfShape(pos, shape);
        switch (shape.operation)
        {
        default:
            float2 result = opSmoothUnion(dist, minDist, shape.info.blendAmount);
            minDist = result.x;
            colour = lerp((float3)shape.colour, colour, result.y);
            break;
        case 1:
            minDist = opSmoothSubtraction(dist, minDist, shape.info.blendAmount);
            break;
        case 2:
            minDist = opSmoothIntersection(dist, minDist, shape.info.blendAmount);
            break;
        }
    }
    sdfResult result;

    result.dist = minDist;
    result.colour = colour;

    return result; 
}

float2 normalizeScreenCoords(const float2 screenCoord)
{
    float2 result = 2.0 * (screenCoord / resolution.xy - 0.5);
    result.x *= resolution.x / resolution.y; // Correct for aspect ratio
    return result;
}

float3 calculateNormal(const float3 pos, const float centerDistance)
{
    float epsilon = 0.01; 
    float xDistance = sdfScene(pos + float3(epsilon, 0, 0)).dist;
    float yDistance = sdfScene(pos + float3(0, epsilon, 0)).dist;
    float zDistance = sdfScene(pos + float3(0, 0, epsilon)).dist;
    float3 normal = (float3(xDistance, yDistance, zDistance) - centerDistance) / epsilon;
    return normal;
}

float calcLight(const float3 normal, const float3 lightDir, const float3 viewDir, const float metallicness)
{
    float ambientLight = 0.25;
    float diffuseLight = max(0.0, dot(normal, -lightDir));
    float3 reflectSource = normalize(reflect(-lightDir, normal));
    float specularLight = max(0.0, dot(viewDir, reflectSource));
    specularLight = pow(specularLight, 16.0);
    
    return ambientLight * 1.0 + diffuseLight * 1.0 + specularLight * metallicness;
}

bool calcShadow(const float3 startPos, const float3 lightDir)
{
    const float distThreshold = 0.01;
    const float maxDist = 100.0;
    const int maxIterations = 80;
    
    float totalDist = 0.1;
    
    for (int i = 0; i < maxIterations; i++)
    {
        float3 pos = startPos - lightDir * totalDist;
        sdfResult result = sdfScene(pos);
        totalDist += result.dist;
        
        if (result.dist < distThreshold) return true;
        if (totalDist > maxDist) return false;
    }

    return false;
}

[numthreads(8,8,1)]
void csMain (uint3 id : SV_DispatchThreadID)
{
    const float shadowStrength = 0.3;
    const float distThreshold = 0.01;
    const float maxDist = 100.0;
    const int maxIterations = 150;
    const float outlineThreshold = 0;
    const float3 skyColour = float3(0.675, 0.845, 0.95);
    const float3 lightDir = normalize(float3(-1, -3, 1));
    const float2 uv = normalizeScreenCoords(id.xy);
    const float3 origin = cameraPos;
    
    float3 dir = normalize(float3(uv, 1.0));

    dir.yz = mul(dir.yz, rot2D(-camRotation.x));
    dir.xz = mul(dir.xz, rot2D(camRotation.y));

    float3 objColour = 0;
    float3 surfaceNormal = 0;
    float totalDist = 0.0;

    bool didHit = false;
    bool isOutline = false;
    
    for (int i = 0; i < maxIterations; i++)
    {
        float3 pos = origin + dir * totalDist;
        sdfResult result = sdfScene(pos);
        float dist = result.dist;
        objColour = result.colour;
        totalDist += dist;

        if (dist < distThreshold)
        {
            didHit = true;
            isOutline = false;
            surfaceNormal = calculateNormal(pos, dist);
            break;
        } if (dist < outlineThreshold)
            isOutline = true;

        if (totalDist > maxDist) break;
    }
    
    if (isOutline)
        screenTexture[id.xy] = 1;
    else if (didHit)
    {
        float3 pos = origin + dir * totalDist;
        float mult = calcShadow(pos, lightDir) ? shadowStrength : calcLight(surfaceNormal, lightDir , dir, 1.0);
        screenTexture[id.xy] = float4(lerp(objColour * mult, skyColour, pow(totalDist / maxDist, 2)), 1);
    }
    else screenTexture[id.xy] = float4(skyColour, 1);
}
